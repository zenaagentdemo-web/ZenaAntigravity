// Prisma schema for Zena AI Real Estate PWA

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model with authentication fields
model User {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String
  name         String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  preferences  Json?    // UserPreferences as JSON

  // Relations
  emailAccounts    EmailAccount[]
  calendarAccounts CalendarAccount[]
  threads          Thread[]
  contacts         Contact[]
  properties       Property[]
  deals            Deal[]
  timelineEvents   TimelineEvent[]
  tasks            Task[]
  voiceNotes       VoiceNote[]
  crmIntegrations  CRMIntegration[]
  exports          Export[]
  pushSubscriptions PushSubscription[]
  chatConversations ChatConversation[]
  commissionFormulas CommissionFormula[]
  zenaActions       ZenaAction[]
  nurtureSequences  NurtureSequence[]

  @@index([email])
}

// Email account model
model EmailAccount {
  id           String   @id @default(uuid())
  userId       String
  provider     String   // 'gmail' | 'outlook' | 'icloud' | 'yahoo' | 'imap'
  email        String
  accessToken  String   // encrypted
  refreshToken String   // encrypted
  tokenExpiry  DateTime
  lastSyncAt   DateTime?
  syncEnabled  Boolean  @default(true)
  createdAt    DateTime @default(now())

  // Relations
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  threads Thread[]

  @@index([userId])
  @@index([email])
}

// Calendar account model
model CalendarAccount {
  id           String   @id @default(uuid())
  userId       String
  provider     String   // 'google' | 'microsoft' | 'icloud'
  email        String
  accessToken  String   // encrypted
  refreshToken String   // encrypted
  tokenExpiry  DateTime
  lastSyncAt   DateTime?
  syncEnabled  Boolean  @default(true)
  createdAt    DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([email])
}

// Thread model with classification and categorization
model Thread {
  id               String    @id @default(uuid())
  userId           String
  emailAccountId   String
  externalId       String    // provider's thread ID
  subject          String
  participants     Json      // Participant[]
  classification   String    // 'buyer' | 'vendor' | 'market' | 'lawyer_broker' | 'noise'
  category         String    // 'focus' | 'waiting'
  propertyId       String?
  dealId           String?
  stage            String?   // DealStage
  riskLevel        String    @default("none") // 'none' | 'low' | 'medium' | 'high'
  riskReason       String?
  nextAction       String?
  nextActionOwner  String    // 'agent' | 'other'
  lastMessageAt    DateTime
  lastReplyAt      DateTime?
  summary          String    @db.Text
  draftResponse    String?   @db.Text
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // Relations
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  emailAccount  EmailAccount  @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  property      Property?     @relation(fields: [propertyId], references: [id])
  deal          Deal?         @relation(fields: [dealId], references: [id])
  messages      Message[]

  @@index([userId])
  @@index([emailAccountId])
  @@index([propertyId])
  @@index([dealId])
  @@index([category])
  @@index([classification])
  @@index([riskLevel])
  @@index([lastMessageAt])
}

// Message model for storing individual email messages
model Message {
  id          String   @id @default(uuid())
  threadId    String
  externalId  String   // provider's message ID
  from        Json     // { name: string, email: string }
  to          Json[]   // Array of { name: string, email: string }
  cc          Json[]   // Array of { name: string, email: string }
  subject     String
  body        String   @db.Text
  bodyHtml    String?  @db.Text
  sentAt      DateTime
  receivedAt  DateTime
  isFromUser  Boolean  @default(false)
  createdAt   DateTime @default(now())

  // Relations
  thread Thread @relation(fields: [threadId], references: [id], onDelete: Cascade)

  @@unique([threadId, externalId])
  @@index([threadId])
  @@index([sentAt])
}

// Contact model with deduplication support
model Contact {
  id               String   @id @default(uuid())
  userId           String
  name             String
  emails           String[] // Array of email addresses
  phones           String[] // Array of phone numbers
  role             String   // 'buyer' | 'vendor' | 'market' | 'other'
  relationshipNotes Json[]  // RelationshipNote[]
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  deals      Deal[]     @relation("DealContacts")
  vendorProperties Property[] @relation("VendorContacts")
  buyerProperties  Property[] @relation("BuyerContacts")
  nurtureSequences NurtureSequence[]

  @@index([userId])
  @@index([emails])
  @@index([role])
}

// Property model with milestone tracking
model Property {
  id         String   @id @default(uuid())
  userId     String
  address    String
  type       String   @default("residential") // 'residential' | 'commercial' | 'land'
  status     String   @default("active")      // 'active' | 'under_contract' | 'sold' | 'withdrawn'
  listingPrice Decimal? @db.Decimal(12, 2)
  bedrooms   Int?
  bathrooms  Int?
  landSize   String?
  milestones Json[]   // CampaignMilestone[]
  riskOverview String? @db.Text
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  vendors  Contact[] @relation("VendorContacts")
  buyers   Contact[] @relation("BuyerContacts")
  threads  Thread[]
  deals    Deal[]

  @@index([userId])
  @@index([address])
}

// Deal model with stage and risk tracking
model Deal {
  id              String   @id @default(uuid())
  userId          String
  threadId        String?
  propertyId      String?
  
  // Core fields
  stage           String   // BuyerStage or SellerStage
  riskLevel       String   @default("none") // 'none' | 'low' | 'medium' | 'high' | 'critical'
  riskFlags       String[] // Array of risk indicators
  nextAction      String?  @db.Text
  nextActionOwner String   // 'agent' | 'other'
  summary         String   @db.Text
  
  // Pipeline & Sale Type
  pipelineType    String   @default("buyer") // 'buyer' | 'seller'
  saleMethod      String   @default("negotiation") // 'negotiation' | 'auction' | 'tender' | 'deadline_sale'
  
  // Financial Tracking
  dealValue             Decimal?  @db.Decimal(12, 2) // Property price / expected price
  commissionFormulaId   String?   // Link to user's commission formula
  estimatedCommission   Decimal?  @db.Decimal(10, 2) // Auto-calculated from formula
  
  // Deadline Intelligence
  conditions      Json?    // Array of DealCondition objects
  settlementDate  DateTime?
  goLiveDate      DateTime? // For listings: when marketing goes live
  auctionDate     DateTime? // For auctions
  tenderCloseDate DateTime? // For tenders
  
  // Tracking Metrics
  stageEnteredAt  DateTime @default(now()) // For "days in stage" calculation
  lastContactAt   DateTime? // Last communication with client
  
  // Conjunctional Sales (Phase 3)
  isConjunctional          Boolean @default(false)
  conjunctionalAgencyId    String?
  conjunctionalAgencyName  String?        // e.g., "Harcourts Ponsonby"
  conjunctionalSplit       Float?         // 0.5 = 50/50 split (our share)
  isListingAgent           Boolean @default(true) // true = we're listing, false = we're selling
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  property          Property?          @relation(fields: [propertyId], references: [id])
  commissionFormula CommissionFormula? @relation(fields: [commissionFormulaId], references: [id])
  contacts          Contact[]          @relation("DealContacts")
  threads           Thread[]
  zenaActions       ZenaAction[]
  nurtureSequences  NurtureSequence[]

  @@index([userId])
  @@index([propertyId])
  @@index([stage])
  @@index([riskLevel])
  @@index([pipelineType])
  @@index([stageEnteredAt])
}

// Timeline event model
model TimelineEvent {
  id         String   @id @default(uuid())
  userId     String
  type       String   // 'email' | 'call' | 'meeting' | 'task' | 'note' | 'voice_note'
  entityType String   // 'thread' | 'contact' | 'property' | 'deal' | 'calendar_event'
  entityId   String
  summary    String   @db.Text
  content    String?  @db.Text
  metadata   Json?
  timestamp  DateTime
  createdAt  DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([entityType, entityId])
  @@index([timestamp])
}

// Task model
model Task {
  id          String    @id @default(uuid())
  userId      String
  label       String
  status      String    @default("open") // 'open' | 'completed'
  dueDate     DateTime?
  dealId      String?
  propertyId  String?
  contactId   String?
  source      String    // 'email' | 'voice_note' | 'manual' | 'ai_suggested'
  createdAt   DateTime  @default(now())
  completedAt DateTime?

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([dueDate])
}

// Voice note model
model VoiceNote {
  id               String    @id @default(uuid())
  userId           String
  audioUrl         String
  transcript       String    @db.Text
  extractedEntities Json[]   // ExtractedEntity[]
  processingStatus String    @default("pending") // 'pending' | 'processing' | 'completed' | 'failed'
  createdAt        DateTime  @default(now())
  processedAt      DateTime?

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([processingStatus])
}

// CRM integration model
model CRMIntegration {
  id          String    @id @default(uuid())
  userId      String
  provider    String    // 'mri_vault' | 'salesforce' | 'top_producer' | 'kvcore' | 'follow_up_boss'
  credentials String    // encrypted
  syncEnabled Boolean   @default(true)
  lastSyncAt  DateTime?
  syncConfig  Json      // CRMSyncConfig
  createdAt   DateTime  @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([provider])
}

// Export model
model Export {
  id          String    @id @default(uuid())
  userId      String
  type        String    // 'contacts' | 'properties' | 'deals'
  format      String    // 'csv' | 'xlsx' | 'vcard'
  fileUrl     String
  recordCount Int
  status      String    @default("pending") // 'pending' | 'processing' | 'completed' | 'failed'
  createdAt   DateTime  @default(now())
  completedAt DateTime?

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
}

// Push subscription model for web push notifications
model PushSubscription {
  id         String   @id @default(uuid())
  userId     String
  endpoint   String   @unique
  keys       Json     // { p256dh: string, auth: string }
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([endpoint])
}

// Notification preferences model
model NotificationPreferences {
  id                      String   @id @default(uuid())
  userId                  String   @unique
  highPriorityThreads     Boolean  @default(true)
  riskDeals               Boolean  @default(true)
  calendarReminders       Boolean  @default(true)
  taskReminders           Boolean  @default(true)
  newThreads              Boolean  @default(false)
  // Deal Flow preferences
  dealDeadlines           Boolean  @default(true)
  morningBriefing         Boolean  @default(true)
  settlementCountdown     Boolean  @default(true)
  staleDealAlerts         Boolean  @default(true)
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  @@index([userId])
}

// Chat conversation model for Ask Zena history
model ChatConversation {
  id        String   @id @default(uuid())
  userId    String
  title     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user     User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages ChatMessage[]

  @@index([userId])
}

// Chat message model
model ChatMessage {
  id             String   @id @default(uuid())
  conversationId String
  role           String   // 'user' | 'assistant'
  content        String   @db.Text
  attachments    Json?    // Array of { type: string, url: string, name: string }
  createdAt      DateTime @default(now())

  // Relations
  conversation ChatConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
}

// Commission formula model for tiered commission structures
model CommissionFormula {
  id        String   @id @default(uuid())
  userId    String
  name      String   // e.g., "Standard Residential", "Premium Listings"
  isDefault Boolean  @default(false)
  tiers     Json     // Array of CommissionTier: { minPrice, maxPrice, rate, fixedFee? }
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user  User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  deals Deal[]

  @@index([userId])
  @@index([isDefault])
}

// Zena Action model for AI-powered deal recommendations
model ZenaAction {
  id          String    @id @default(uuid())
  userId      String
  dealId      String
  type        String    // 'nudge_client' | 'finance_followup' | 'lim_reminder' | 'pre_settlement_check' | 'insurance_reminder' | 'vendor_update' | 'offer_summary' | 'stale_deal_alert'
  status      String    @default("pending") // 'pending' | 'executed' | 'dismissed'
  output      String    @db.Text // Generated draft or message
  triggeredAt DateTime  @default(now())
  executedAt  DateTime?
  dismissedAt DateTime?
  
  // Relations
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  deal        Deal      @relation(fields: [dealId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([dealId])
  @@index([status])
  @@index([type])
}

// Phase 3: Post-Settlement Nurture Sequence
model NurtureSequence {
  id            String    @id @default(uuid())
  userId        String
  dealId        String
  contactId     String
  
  status        String    @default("active")  // 'active' | 'completed' | 'paused'
  currentStep   Int       @default(1)         // Current step in nurture sequence (1-5+)
  nextTouchDate DateTime                      // When next touch is due
  lastTouchAt   DateTime?                     // When last touch was completed
  
  // Tracking
  touchCount    Int       @default(0)         // Total touches completed
  notes         String?   @db.Text            // Agent notes
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // Relations
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  deal          Deal      @relation(fields: [dealId], references: [id], onDelete: Cascade)
  contact       Contact   @relation(fields: [contactId], references: [id], onDelete: Cascade)
  
  @@index([userId, status])
  @@index([nextTouchDate])
  @@index([dealId])
}

